"use strict";

var _react = _interopRequireWildcard(require("react"));
var _svgosm = require("./svgosm.js");
var _propTypes = _interopRequireDefault(require("prop-types"));
const _excluded = ["width", "height", "placeholder", "className", "title", "desc", "role"];
/* eslint-disable complexity, max-statements, no-console, no-process-env  */
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
/**
 * Detect if we are running in a Node.js environment.
 *
 * @type {Boolean}
 * @private
 */
const isNode = !!(typeof process !== 'undefined' && process.versions && process.versions.node);

/**
 * Generates our dedicated Icon component.
 *
 * @param {String} displayName Name of the Icon.
 * @param {String} deprecated Indication if the icon should be deprecated
 * @returns {React.Component} The React Component.
 * @public
 */
module.exports = function create(displayName, deprecated) {
  const warned = {};

  /**
   * The base component that renders the Icon.
   *
   * @constructor
   * @param {Object} props All the props
   * @param {Number} props.width Width of the icon.
   * @param {Number} props.height Height of the icon.
   * @param {String} props.className Class name of the icon.
   * @param {String} props.title A11y title of the icon.
   * @param {String} props.desc A11y description of the icon.
   * @param {String} props.role A11y role for the icon.
   * @param {Object} props.placeholder Information used to statically render the icon.
   * @param {Object} props.props The rest of the props that are spread on the <use> tag.
   * @param {React.Ref} ref Forwarding reference
   * @private
   */
  const Fwd = /*#__PURE__*/_react.default.forwardRef(function Icon(_ref, ref) {
    let {
        width = '1.5em',
        height = '1.5em',
        placeholder,
        className,
        title,
        desc,
        role = 'presentation'
      } = _ref,
      rest = _objectWithoutProperties(_ref, _excluded);
    const sym = (0, _react.useMemo)(() => {
      let result = _svgosm.svgosm.get(displayName, function extract() {
        const details = _svgosm.svgosm.extract(`uxp-icon-${displayName}`);
        if (!details) return;
        return Object.assign(details, {
          title: title,
          desc: desc
        });
      }) || placeholder;
      if (!result) {
        //
        // If we don't have a result from the svg manager it's most likely caused
        // by missing CSS so we're going to advice the user, only dev/test,
        // in the browser (because we don't care bout node.js env) that they need
        // to import the CSS.
        //
        if (process.env.NODE_ENV !== 'production' && !isNode && !warned.css) {
          console.log(`Unable to render the icon, did you forget to include the required css? @ux/icon/${displayName}/index.(css|scss)?`);
          warned.css = true;
        }

        // SSR fallback
        result = {
          link: `#${_svgosm.svgosm.uid(displayName)}`
        };
      }
      return result;
    }, [title, desc, placeholder]);
    const props = {};
    const svg = {
      className: ['uxicon-svg-container', className].join(' ').trim(),
      height: height || sym.height,
      width: width || sym.width,
      role,
      ref
    };

    //
    // Extract the `aria-` prefixed props from the supplied props as they
    // need to be applied to the <svg> element, the rest of the props
    // need to be applied to the <use> element, for styling purposes.
    //
    Object.keys(rest).forEach(function propSort(key) {
      if (key.startsWith('aria-') || key.startsWith('data-')) svg[key] = rest[key];else props[key] = rest[key];
    });

    //
    // When no `aria-labelledby` is provided to us, but we did receive a title
    // or a desc, we're going to generate the correct aria- role by default.
    //
    if (!svg['aria-labelledby'] && (title || desc)) {
      const unique = sym.link.slice(1);
      const labels = [];
      if (title) labels.push(`${unique}-title`);
      if (desc) labels.push(`${unique}-desc`);
      svg['aria-labelledby'] = labels.join(' ');
    }
    return /*#__PURE__*/_react.default.createElement('svg', svg, /*#__PURE__*/_react.default.createElement('use', _objectSpread(_objectSpread({
      fill: 'currentColor'
    }, props), {}, {
      xlinkHref: sym.link
    })));
  });

  //
  // Ease debugging.
  //
  Fwd.displayName = displayName + 'Icon';

  /**
   * PropType validation.
   *
   * @type {Object}
   * @private
   */
  Fwd.propTypes = {
    width: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    height: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    placeholder: _propTypes.default.shape({
      link: _propTypes.default.string
    }),
    className: _propTypes.default.string,
    desc: _propTypes.default.string,
    title: _propTypes.default.string,
    role: _propTypes.default.string
  };

  //
  // Ensure that this is not active in production environments, should be
  // auto deleted by minifiers.
  //
  if (process.env.NODE_ENV !== 'production') {
    //
    // Please note that the icon is passed as string because of our
    // {namespace:field} template pattern. The files are processed with babel
    // which thinks it's an object pattern and reformats it as a pretty object
    // which breaks the template engine. So we're just gonna pass it as string
    // to work around that limitation.
    //
    if (deprecated === 'true' && !warned.dep) {
      console.log(`The icon "${displayName}" is deprecated and will be removed in the next major release of @ux/icon`);
      warned.dep = true;
    }
  }
  return Fwd;
};